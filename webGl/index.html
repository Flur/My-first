<!DOCTYPE html>
<html>
  <head>
    <title>Flur</title>
    <meta charset="utf-8">
  </head>

  <body>
    <canvas id="canvas" width="600" height="600"></canvas>

    <script type="x-shader/x-fragment" id="shader-fs">
      varying highp vec4 vColor;
      void main(void) {
        gl_FragColor = vColor;
      }
    </script>

    <script type="x-shader/x-vertex" id="shader-vs">
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexColor;
      void main(void) {
        gl_Position = vec4(aVertexPosition, 1.0);
        vColor = vec4(aVertexColor, 1.0);
      }
    </script>

    <script type="text/javascript">

      window.onload = function () {
        var gl;
        var shaderProgram;
        var vertexBuffer;
        var indexBuffer;
        var colorBuffer;

        function init() {

          var canvas = document.getElementById('canvas');
          var names = ['webgl', 'webkit-3D', 'moz-webgl', 'experimental-webgl'];
          var namesLength = names.length;

          for (var i = 0 ; i < namesLength ; i++) {
            try {
              gl = canvas.getContext(names[i]);
              if (gl) {
                console.log(names[i]);
                break;
              }
            } catch(e) {
              alert('No webgl');
            }
          }

          initShaders();

          initBuffers();

          draw();
          
          //clearCanvas(gl, color);
        }
        
        

        function initShaders() {

          // creating shaders from scripts
          var fragmentShader = getShader(gl.FRAGMENT_SHADER, 'shader-fs');
          var vertexShader = getShader(gl.VERTEX_SHADER, 'shader-vs');
          // creating program
          shaderProgram = gl.createProgram();

          // bind shaders to program & program to ctx
          gl.attachShader(shaderProgram, fragmentShader);
          gl.attachShader(shaderProgram, vertexShader);
          gl.linkProgram(shaderProgram);
          gl.useProgram(shaderProgram);


          // creating attribute 
          shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
          // binding attribute
          gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
          shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
          // binding attribute
          gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
          
        
        }

        // Функция создания шейдера по типу и id источника в структуре DOM
        function getShader(type,id) {
          var source = document.getElementById(id).innerHTML;
          // создаем шейдер по типу
          var shader = gl.createShader(type);
          // установка источника шейдера
          gl.shaderSource(shader, source);
          // компилируем шейдер
          gl.compileShader(shader);
         
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
              alert("Ошибка компиляции шейдера: " + gl.getShaderInfoLog(shader));
              gl.deleteShader(shader);   
              return null;
          }
          return shader;  
        }

        function initBuffers() {

          var colors =[
            1.0, 0.0, 0.0, 
            0.0, 0.0, 1.0, 
            0.0, 1.0, 0.0
          ];

          var vertices = [
            0.5, 0.5, 0.0, 
            -0.5, 0.5, 0.0,
            0.5, -0.5, 0.0,
          ];

          var indeces = [0,1,2,0,3,2];

          vertexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          vertexBuffer.itemSize = 3;

          indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indeces), gl.STATIC_DRAW)
          vertexBuffer.numberOfItems = 3;

          colorBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          colorBuffer.itemSize = 3;
        }

        function draw() {
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          // place for drawing on the canvas
          gl.viewport(0, 0, 600, 600);
          gl.clear(gl.COLOR_BUFFER_BIT);

          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);


          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

          gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.itemSize);  
        }

        init();

      }

      function clearCanvas(ctx, colorArray) {
        if (!ctx) {
          return;
        }
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        //ctx.viewport(0, 0, 600, 600)
        gl.clearColor(colorArray[0], colorArray[1], colorArray[2], colorArray[3]);
      }

    </script>

  </body>
</html>
